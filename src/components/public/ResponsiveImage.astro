---
export const prerender = true;

import { Image } from 'astro:assets';
import Text from '../i18n/Text.astro';

interface Props {
    name: string;
    alt?: string;
    className?: string;
    loading?: 'eager' | 'lazy';
    decoding?: 'sync' | 'async' | 'auto';
    sizes?: string;
    objectFit?: 'cover' | 'contain' | 'fill' | 'scale-down' | 'none';
    objectPosition?: string;
    showFallback?: boolean;
    fallbackText?: string;
    fallbackIcon?: 'image' | 'gallery' | 'photo' | 'picture';
    width?: number;
    height?: number;
    priority?: boolean;
}

const {
    name,
    alt,
    className = '',
    loading = 'lazy',
    decoding = 'async',
    sizes = '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw',
    objectFit = 'cover',
    objectPosition = 'center',
    showFallback = true,
    fallbackText,
    fallbackIcon = 'image',
    width,
    height,
    priority = false
} = Astro.props;

// Importar todas las imágenes descargadas usando glob
const imagePath = '/public/downloaded-images/' + name;
const images = import.meta.glob('/public/downloaded-images/*.*', { eager: true });
const imageData = images[imagePath] ? images[imagePath]?.default : undefined;

// Avisos en modo desarrollo
if (import.meta.env.DEV) {
    if (!imageData) {
        console.warn(
            `  ResponsiveImage [${name}]: Imagen NO encontrada en cache.\n` +
            `   → Añádela a src/config/images.json y ejecuta: npm run download-images\n` +
            `   → Imágenes disponibles: ${Object.keys(images).length}`
        );
    } else {
        console.debug(`✓ ResponsiveImage [${name}]: Cargada desde ${imagePath}`);
    }
}

const icons = {
    image: `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
        <circle cx="8.5" cy="8.5" r="1.5"/>
        <polyline points="21,15 16,10 5,21"/>
    </svg>`,
    gallery: `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
        <path d="m9 9 5 12 4-18"/>
    </svg>`,
    photo: `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="m9 9 5 12 4-18"/>
        <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/>
        <circle cx="12" cy="13" r="3"/>
    </svg>`,
    picture: `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M18 22H4a2 2 0 0 1-2-2V6"/>
        <path d="m22 13-1.296-1.296a2.41 2.41 0 0 0-3.408 0L11 18"/>
        <circle cx="12" cy="8" r="2"/>
        <rect width="16" height="16" x="6" y="2" rx="2"/>
    </svg>`
};

const altText = alt || `Imagen ${name}`;
const finalLoading = priority ? 'eager' : loading;
const objectFitClass = `object-${objectFit}`;
const objectPositionClass = objectPosition === 'center' ? 'object-center' :
                            objectPosition === 'top' ? 'object-top' :
                            objectPosition === 'bottom' ? 'object-bottom' :
                            objectPosition === 'left' ? 'object-left' :
                            objectPosition === 'right' ? 'object-right' : 'object-center';
---

{imageData ? (
    <div class={`responsive-image-wrapper ${className}`}>
        <div class="image-skeleton"></div>
        <Image
            class={`responsive-image ${objectFitClass} ${objectPositionClass}`}
            src={imageData}
            alt={altText}
            loading={finalLoading}
            decoding={decoding}
            widths={[400, 800, 1200, 1600, 2000]}
            sizes={sizes}
            format="webp"
            data-image-id={name}
            width={width}
            height={height}
        />
    </div>
) : showFallback ? (
    <div class={`responsive-image-fallback ${className}`} data-image-id={name}>
        <div class="fallback-content">
            <div class="fallback-icon" set:html={icons[fallbackIcon]} />
            <div class="fallback-text">
                <p class="fallback-title">
                    {fallbackText || (
                        <Text key="image.not_found" fallback="Imagen no disponible" />
                    )}
                </p>
                {import.meta.env.DEV && (
                    <div class="fallback-dev-info">
                        <small class="fallback-debug">
                            Imagen: <strong>{name}</strong>
                        </small>
                        <small class="fallback-instructions">
                            Añádela a <code>src/config/images.json</code><br/>
                            Luego ejecuta: <code>npm run download-images</code>
                        </small>
                    </div>
                )}
            </div>
        </div>
    </div>
) : (
    <div class={`responsive-image-empty ${className}`} data-image-id={name} style="display: none;"></div>
)}

<style is:inline>
    .responsive-image-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    .image-skeleton {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
            90deg,
            rgba(255, 255, 255, 0.05) 0%,
            rgba(255, 255, 255, 0.1) 50%,
            rgba(255, 255, 255, 0.05) 100%
        );
        background-size: 200% 100%;
        animation: shimmer 1.5s ease-in-out infinite;
        opacity: 1;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 1;
    }

    .image-skeleton.hidden {
        opacity: 0;
    }

    .responsive-image {
        width: 100%;
        height: 100%;
        display: block;
        opacity: 0;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 2;
    }

    .responsive-image.loaded {
        opacity: 1;
    }

    .responsive-image-fallback {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.1);
        border: 2px dashed rgba(244, 162, 97, 0.3);
        border-radius: 12px;
        color: rgba(244, 162, 97, 0.6);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        min-height: 200px;
    }

    .responsive-image-fallback:hover {
        border-color: rgba(244, 162, 97, 0.5);
        background: rgba(244, 162, 97, 0.05);
    }

    .fallback-content {
        text-align: center;
        padding: 2rem;
        max-width: 300px;
    }

    .fallback-icon {
        margin-bottom: 1rem;
        opacity: 0.7;
        color: rgba(244, 162, 97, 0.5);
    }

    .fallback-icon :global(svg) {
        width: 48px;
        height: 48px;
    }

    .fallback-title {
        font-size: 1rem;
        margin-bottom: 0.5rem;
        color: rgba(244, 162, 97, 0.8);
        font-weight: 500;
    }

    .fallback-dev-info {
        margin-top: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .fallback-debug {
        font-size: 0.85rem;
        font-family: 'Courier New', monospace;
        color: #ff9800;
        display: block;
        padding: 0.5rem 0.75rem;
        background: rgba(255, 152, 0, 0.1);
        border-radius: 6px;
        border-left: 3px solid #ff9800;
    }

    .fallback-debug strong {
        color: #f57c00;
        font-weight: 600;
    }

    .fallback-instructions {
        font-size: 0.75rem;
        font-family: 'Courier New', monospace;
        color: #666;
        display: block;
        padding: 0.5rem 0.75rem;
        background: rgba(0, 0, 0, 0.05);
        border-radius: 6px;
        line-height: 1.6;
    }

    .fallback-instructions code {
        background: rgba(244, 162, 97, 0.2);
        padding: 0.125rem 0.375rem;
        border-radius: 3px;
        font-size: 0.7rem;
        color: rgba(244, 162, 97, 1);
        font-weight: 600;
    }

    .responsive-image-fallback.small {
        min-height: 100px;
    }

    .responsive-image-fallback.small .fallback-content {
        padding: 1rem;
    }

    .responsive-image-fallback.small .fallback-icon :global(svg) {
        width: 32px;
        height: 32px;
    }

    .responsive-image-fallback.large {
        min-height: 400px;
    }

    .responsive-image-fallback.large .fallback-content {
        padding: 3rem;
    }

    .responsive-image-fallback.large .fallback-icon :global(svg) {
        width: 64px;
        height: 64px;
    }

    .responsive-image-fallback.hero {
        background: rgba(0, 0, 0, 0.3);
        border: 2px dashed rgba(255, 255, 255, 0.3);
        color: rgba(255, 255, 255, 0.8);
        min-height: 50vh;
    }

    .responsive-image-fallback.hero .fallback-title {
        color: rgba(255, 255, 255, 0.9);
    }

    .responsive-image-fallback.hero .fallback-icon {
        color: rgba(255, 255, 255, 0.7);
    }

    @keyframes shimmer {
        0% {
            background-position: -200% 0;
        }
        100% {
            background-position: 200% 0;
        }
    }

    @media (max-width: 768px) {
        .fallback-content {
            padding: 1.5rem;
        }

        .fallback-icon :global(svg) {
            width: 40px;
            height: 40px;
        }

        .fallback-title {
            font-size: 0.9rem;
        }
    }
</style>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const imageWrappers = document.querySelectorAll('.responsive-image-wrapper');

        imageWrappers.forEach(wrapper => {
            const img = wrapper.querySelector('.responsive-image');
            const skeleton = wrapper.querySelector('.image-skeleton');

            if (!img) return;

            const handleImageLoad = () => {
                img.classList.add('loaded');
                if (skeleton) {
                    skeleton.classList.add('hidden');
                }
            };

            if (img.complete && img.naturalHeight !== 0) {
                handleImageLoad();
            } else {
                img.addEventListener('load', handleImageLoad);

                img.addEventListener('error', () => {
                    if (img.dataset.imageId) {
                        console.warn(`Error cargando imagen: ${img.dataset.imageId}`);
                    }
                    // Ocultar skeleton incluso si hay error
                    if (skeleton) {
                        skeleton.classList.add('hidden');
                    }
                });
            }
        });

        // También manejar imágenes que no están en wrappers (fallback compatibility)
        const standaloneImages = document.querySelectorAll('.responsive-image:not(.responsive-image-wrapper .responsive-image)');
        standaloneImages.forEach(img => {
            if (img.complete && img.naturalHeight !== 0) {
                img.classList.add('loaded');
            } else {
                img.addEventListener('load', () => {
                    img.classList.add('loaded');
                });

                img.addEventListener('error', () => {
                    if (img.dataset.imageId) {
                        console.warn(`Error cargando imagen: ${img.dataset.imageId}`);
                    }
                });
            }
        });
    });
</script>
